{
  "noir_version": "0.23.0+602f23f4fb698cf6e37071936a2a46593a998d08",
  "name": "Counter",
  "functions": [
    {
      "name": "increment",
      "function_type": "Secret",
      "is_internal": false,
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::abi::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "portal_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_contract_deployment",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "note_hash_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "nullifier_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "contract_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "l1_to_l2_message_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "archive_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "public_data_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "contract_deployment_data",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData",
                    "fields": [
                      {
                        "name": "deployer_public_key",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "constructor_vk_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "function_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "contract_address_salt",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "portal_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "private_global_variables",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::abi::PrivateGlobalVariables",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "param_witnesses": {
          "inputs": [
            {
              "start": 0,
              "end": 23
            }
          ],
          "owner": [
            {
              "start": 23,
              "end": 24
            }
          ]
        },
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "storage_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "portal_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::EthAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_delegate_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "is_contract_deployment",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "start_side_effect_counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "return_values",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "read_requests",
                "type": {
                  "kind": "array",
                  "length": 32,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffect",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "new_commitments",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffect",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "new_nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_stack_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "public_call_stack_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "new_l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "encrypted_logs_hash",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "unencrypted_logs_hash",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "encrypted_log_preimages_length",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "unencrypted_log_preimages_length",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "note_hash_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "nullifier_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "contract_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "l1_to_l2_message_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "archive_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "public_data_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_deployment_data",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData",
                  "fields": [
                    {
                      "name": "deployer_public_key",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint",
                        "fields": [
                          {
                            "name": "x",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "y",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "constructor_vk_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "function_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "contract_address_salt",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "portal_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::EthAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "version",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "return_witnesses": [
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          123,
          124,
          125,
          126,
          127,
          128,
          129,
          130,
          131,
          132,
          133,
          134,
          135,
          136,
          137,
          138,
          139,
          140,
          141,
          142,
          143,
          144,
          145,
          146,
          147,
          148,
          149,
          150,
          151,
          152,
          153,
          154,
          155,
          156,
          157,
          158,
          159,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          187,
          188,
          189,
          190,
          191,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230
        ]
      },
      "bytecode": "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",
      "debug_symbols": "7ZjbahsxEIbfRddm0Uhz9KuUXJg2hUBwSu07s+9e21kdkggrXUPwJrkyhn+03/waz8z64B6ffm72D0/bnVsfHLn1j4Pb/dlsT992+83fvVv7lbvf/jp+jiv3++Hx3q2jjas3suA9Tcrgg2SxNMURMYnRQxYDSUMN3iSdDeBPj6/0dyvHC+WWD+NG0SSmqNdya4sb0CQFEdBlegspTZOQpRbn0NhN0YC/Ggc8SnkEXgYyhaT1wJcPppDOJSzHAvMZHJYKHpYKHpcKjl3wYD3wGDKM+BdPeKsWTO1LqKIRONPQ9TQgqQNA8NahgQiZHbVqGNhCD5zQq96CLSnnNsQYi5Qa0iNBnLQRUF5Y0gBG0gxs0FN3Wxx/FsMpQYj3HcODJb/rU2eNT5Bb9k8l+Wd1FeKZXJdCrq/J7ZbJjTK5WadmVdIKyubLuepPaQb/NdKEW07zONAs//5BLycamZMpkY06vTkwJY7Aoh01+TTwicpPmePZwvBt4TssFMgjgqS2sLVelVUsFrsh4pwhEeL3/bznfnKKWo3wqcTxy1qo+XVfqbcdRk6FiNVyjf550x+a27UV9JKmPIfI0H6xoew7Q7kqykE4J6hJh0q575U742l0DM31K2aDsXo3mgoJBp0RYzNi2n8f9ILgv4NwaG+hyKne0fRVMZyCdE5Q0wjKl8TVRs063o3jPw=="
    },
    {
      "name": "constructor",
      "function_type": "Secret",
      "is_internal": false,
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::abi::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "portal_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_contract_deployment",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "note_hash_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "nullifier_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "contract_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "l1_to_l2_message_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "archive_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "public_data_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "contract_deployment_data",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData",
                    "fields": [
                      {
                        "name": "deployer_public_key",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "constructor_vk_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "function_tree_root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "contract_address_salt",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "portal_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "private_global_variables",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::abi::PrivateGlobalVariables",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "headstart",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 120
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "param_witnesses": {
          "headstart": [
            {
              "start": 23,
              "end": 24
            }
          ],
          "inputs": [
            {
              "start": 0,
              "end": 23
            }
          ],
          "owner": [
            {
              "start": 24,
              "end": 25
            }
          ]
        },
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "storage_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "portal_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::EthAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_delegate_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "is_contract_deployment",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "start_side_effect_counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "return_values",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "read_requests",
                "type": {
                  "kind": "array",
                  "length": 32,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffect",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "new_commitments",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffect",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "new_nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_stack_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "public_call_stack_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "new_l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "encrypted_logs_hash",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "unencrypted_logs_hash",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "encrypted_log_preimages_length",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "unencrypted_log_preimages_length",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "note_hash_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "nullifier_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "contract_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "l1_to_l2_message_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "archive_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "public_data_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_deployment_data",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData",
                  "fields": [
                    {
                      "name": "deployer_public_key",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint",
                        "fields": [
                          {
                            "name": "x",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "y",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "constructor_vk_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "function_tree_root",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "contract_address_salt",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "portal_contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::EthAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "version",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "return_witnesses": [
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          123,
          124,
          125,
          126,
          127,
          128,
          129,
          130,
          131,
          132,
          133,
          134,
          135,
          136,
          137,
          138,
          139,
          140,
          141,
          142,
          143,
          144,
          145,
          146,
          147,
          148,
          149,
          150,
          151,
          152,
          153,
          154,
          155,
          156,
          157,
          158,
          159,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          187,
          188,
          189,
          190,
          191,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231
        ]
      },
      "bytecode": "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",
      "debug_symbols": "7ZjbahsxEIbfRdfGaKQ5+lVKLkybQiA4pfad2XevvVkdkggrXUPwJrkyhn+03/waz8z66B6ffm4PD0+7vdscHbvNj6Pb/9nuzt/2h+3fg9v4lbvf/Tp9Div3++Hx3m2iDas3suA9Tcrgg2SxNMURMYnRQxYDSUMN3iSdDeDPj6/0dysnC+XWD+NG0SSmqNdyW4sbglgKCiaX6S2kNE1CllqcQwP+tnDgahzwKOUReBnIFJLWA18+mEI6l7AcC8wjeFgqeFwqOC4VnHrgEawHHkOGEf/iCW/Vgql/CVU0AiMNX08D4rPn3jo0p/MyO2rVMLCFHjihV70FW1LObYgxFik1pCeCOGkjoLywpAGMpBnYoKfutjj5LIZTghDvO4aHlFysT501P0Fv2T+V5J/VVYgjuS2FXF+RB3/L5EaZ3KxTsyppB2Xz5Vz1Y5rwNdIMt5zmaaBlDgC9nGhkTqZENur05sCUOAKLdtTk08AnKj9ljqOF8dvCd1gokEcESW1ha70qq1gsdkPEOUMi4Pf9vOd+copajfCpxOnLWqj5fV+ptx1GToWI1XKN/nnTXzdNtIJe0pTnEF2338jI0u+DoVwV5SCcE9SkQ6Xc98qd8TQ61s31NWaDsXo3mgoprHVGjM2Iaf+b0QuC/w6idXuLR071jqaviuEcpHOCmkZQviSuNmrW4W4Y/gE="
    },
    {
      "name": "get_counter",
      "function_type": "Unconstrained",
      "is_internal": false,
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "param_witnesses": {
          "owner": [
            {
              "start": 0,
              "end": 1
            }
          ]
        },
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "return_witnesses": [
          1
        ]
      },
      "bytecode": "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",
      "debug_symbols": "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S1Yvmbdt6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTktWOi1Z6bRkpdOSlU5LVjotWem0ZKXTkpVOS1Y6LVnptGSl05KVTkvWOi1Z67RkrdOStU5L1i+Zt23rtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOS9Y6LVnrtGSt05K1TkvWOi1Z67RkrdOStU5L1jotWeu0ZK3TkrVOSzY6LdnotGSj05KNTks2L5m37ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5LNjot2ei0ZKPTko1OSzY6LdnotGSj05KNTks2Oi3Z6LRko9OSjU5Ltjot2eq0ZKvTkq1OS7Yvmbft6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTku2Oi3Z6rRkq9OSrU5Ltjot2eq0ZKvTkq1OS7Y6LdnqtGSr05KtTkt2Oi3Z6bRkp9OSnU5Ldi+Zt+3ptGSn05KdTkt2Oi3Z6bRkp9OSnU5Ldjot2em0ZKfTkp1OS3Y6LdnptGSn05KdTkt2Oi3Z6bRkp9OSnU5Ldjot2em0ZKfTkp1OS3Y6LdnptGSn05KdTkt2Oi3Z6bRkp9OSnU5Ldjot2em0ZKfTkp1OS3Y6LdnptGSn05KdTkt2Oi3Z6bRkp9OSnU5Ldjot2em0ZKfTkp1OS3Y6LdnptGT3R1uyrt++ytwf+yql81Va56uMzldZna9yMl/lj7Zkf+ZXMZ2v4jpfJXS+is7btnXetq3ztm2dt23rvG1b5207Om/b0Xnbjs7bdnTetqPzth2dt+3ovG1H5207Om/b0Xnbrs7bdnXetqvztl2dt+3qvG1X5227Om/b1Xnbrs7bdnXetqfztj2dt+3pvG1P5217Om/b03nbns7b9nTetqfztj2Zt629XjKv2/d3kXnfvr+LzAv3/V1k3rjv7yLzyn1/F5l37vu7yLx0399F5q37/i4yr933dxF675rQe9eE3rsm9N41ofeuCb13Tei9a0LvXRN675rQe9eE3rsu9N51ofeuC713Xei960LvXRd677rQe9eF3rsu9N51ofduCL13Q+i9G0Lv3RB674bQezeE3rsh9N4NofduCL13Q+i9m0Lv3RR676bQezeF3rsp9N5NofduCr13U+i9m0Lv3RR675bQe7eE3rsl9N4tofeuToL2/i5C712dCO39XYTeuzoZ2vu7CL13dUK093cReu/qpGjv7yL03tWJ0d7fRei9q5Ojvb+L0HtXJ0h7fxeh965Okvb+LkLvXZ0o7f1dhN67Olna+7sIvXd1wrT3dxF67+qkae/vIvTe1YnT3t9F6L2rk6e9v4vQe1cnUHt/F6H3rk6i9v4uQu9dnUjt/V2E3rs6mdr7uwi9d3VCtfd3EXrv6qRq7+8i9N7VidXe30XovauTq72/i85714R6NRPq1UyoVzOhXu39k8JC30XnvWtCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1aibUq5lQr2ZCvZoJ9Wom1KuZUK9mQr2aCfVqJtSrmVCvZkK9mgn1ai7Uq7lQr+ZCvZoL9Wr+0nnvulCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqLtSruVCv5kK9mgv1ai7Uq7lQr+ZCvZoL9Wou1Ku5UK/mQr2aC/VqIdSrhVCvFkK9Wgj1avHSee+GUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Woh1KuFUK8WQr1aCPVqIdSrhVCvFkK9Wgj1aiHUq4VQrxZCvVoI9Wop1KulUK+WQr1aCvVq+dJ576ZQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1ainUq6VQr5ZCvVoK9Wop1KulUK+WQr1aCvVqKdSrpVCvlkK9Wgr1aiXUq5VQr1ZCvVoJ9Wr10nnvllCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqJdSrlVCvVkK9Wgn1aiXUq5VQr1ZCvVoJ9Wol1KuVUK9WQr1aCfVqLdSrtVCv1kK9Wgv1av3See+2UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Wot1Ku1UK/WQr1aC/VqLdSrtVCv1kK9Wgv1ai3Uq7VQr9ZCvVoL9Woj1KuNUK82Qr3aCPVq89J5745QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aiPUq41QrzZCvdoI9Woj1KuNUK82Qr3aCPVqI9SrjVCvNkK92gj1aivUq61Qr7ZCvdoK9Wr70nnvrlCvtkK92gr1aivUq61Qr7ZCvdoK9Wor1KutUK+2Qr3aCvVqK9SrrVCvtkK92gr1aivUq61Qr7ZCvdoK9Wor1KutUK+2Qr3aCvVqK9SrrVCvtkK92gr1aivUq+3nXu3f+ptfz/7tl2z+/W90/u2r3/jXX3rx6du8br59ebNX/Pbl7f0p375S6n2l0vtKrfeVRu8rrd5XOrmv9Dlw+4/9Sqb3lVzvK+m9vVPv7Z16b+/Ue3un3ts79d7e+cff3vbK+e1j8u9/qVv79te+rP/+f3D5t//cyt/+Y63725ev13/mL2//mb+8/2f+8t/5Ucb868u3/+1nfLtLeFfwruHdwLuFd8fu+gXvDN45vIN7abiXhntpuJeGe2m4l4Z7GbiXgXsZuJeBexm4l4F7GbiXgXsZuJeBe1m4l4V7WbiXhXtZuJeFe1m4l4V7WbiXhXs5uJeDezm4l4N7ObiXg3s5uJeDezm4l2N7udcL3hm8c3gX8C7hXcG7hncD7xbewb0Y3IvBvRjci8G9GNyLwb0Y3IvBvRjci8G9ONyLw7043IvDvTjci8O9ONyLw7043IvDvQTcS8C9BNxLwL0E3EvAvQTcS8C9BNxLwL0k3EvCvSTcS8K9JNxLwr0k3EvCvSTcS8K9FNxLwb0U3Av03YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LvHfNdfzHffdwbvHN4FvEt4V/Cu4d3Au4V3cC8G92JwLwb3YnAvBvdicC8G92JwLwb3YnAvDvficC8O9+JwLw734nAvDvficC8O9+JwLwH3EnAvAfcScC8B9xJwLwH3EnAvAfcScC8J95JwLwn3knAvCfeScC8J95JwLwn3knAvBfdScC8F91JwLwX3UnAvBfdScC8F91JwLw330nAvDffScC8N99JwLw330nAvDffScC8D9zJwLwP3MnAvA/cycC8D9zJwLwP3MnAvC/eycC8L97JwLwv3snAvC/eycC8L97JwLwf3cnAvB/dycC8H93JwLwf3cnAvB/cCfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0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Xp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di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3YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd9t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruMd/tF/Pd953BO4d3Ae8S3hW8a3g38G7hHdyLwb0Y3IvBvRjci8G9GNyLwb0Y3IvBvRjci8O9ONyLw7043IvDvTjci8O9ONyLw7043EvAvQTcS8C9BNxLwL0E3EvAvQTcS8C9BNxLwr0k3EvCvSTcS8K9JNxLwr0k3EvCvSTcS8G9FNxLwb0U3EvBvRTcS8G9FNxLwb0U3EvDvTTcS8O9NNxLw7003EvDvTTcS8O9NNzLwL0M3MvAvQzcy8C9DNzLwL0M3MvAvQzcy8K9LNzLwr0s3MvCvSzcy8K9LNzLwr0s3MvBvRzcy8G9HNzLwb0c3MvBvRzcy8G9QN816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DTqmQcc06JgGHdM+O2Zlxa93Va/X113G113Du4F3C+8O3flnx/wddwbvHN4FvEt4V/Cu4d3Au4V3cC8G92JwLwb3YnAvBvdicC8G92JwLwb3YnAvDvficC8O9+JwLw734nAvDvficC8O9+JwLwH3EnAvAfcScC8B9xJwLwH3EnAvAfcScC8J95JwLwn3knAvCfeScC8J95JwLwn3knAvBfdScC8F91JwLwX3UnAvBfdScC8F91JwLw330nAvDffScC8N99JwLw330nAvDffScC8D9zJwLwP3MnAvA/cycC8D9zJwLwP3MnAvC/eycC8L97JwLwv3snAvC/eycC8L97JwLwf3cnAvB/dycC8H9wJ916HvOvRdh77r0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N77ju/3yb3f9ik93Ae8S3hW8a3g38G7h3bG77/hu59fdeX66M3jn8C7gXcK7gncN7wbeLbw7djdwLwP3MnAvA/cycC8D9zJwLwP3MnAvA/eycC8L97JwLwv3snAvC/eycC8L97JwLwv3cnAvB/dycC8H93JwLwf3cnAvB/dycC/H9pKvF7wzeOfwLuBdwruCdw3vBt4tvIN7MbgXg3sxuBeDezG4F4N7MbgXg3sxuBeDe3G4F4d7cbgXh3txuBeHe3G4F4d7cbgXh3sJuJeAewm4l4B7CbiXgHsJuJeAewm4l4B7SbiXhHtJuJeEe0m4l4R7SbiXhHtJuJeEeym4l4J7KbiXgnspuJeCeym4l4J7KbiXgnuBvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67jHfnRfz3fedwTuHdwHvEt4VvGt4N/Bu4R3ci8G9GNyLwb0Y3IvBvRjci8G9GNyLwb0Y3IvDvTjci8O9ONyLw7043IvDvTjci8O9ONxLwL0E3EvAvQTcS8C9BNxLwL0E3EvAvQTcS8K9JNxLwr0k3EvCvSTcS8K9JNxLwr0k3EvBvRTcS8G9FNxLwb0U3EvBvRTcS8G9FNxLw7003EvDvTTcS8O9NNxLw7003EvDvTTcy8C9DNzLwL0M3MvAvQzcy8C9DNzLwL0M3MvCvSzcy8K9LNzLwr0s3MvCvSzcy8K9LNzLwb0c3MvBvRzcy8G9HNzLwb0c3MvBvUDfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2CvlvQdwv6bkHfLei7BX23oO8W9N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe82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"
    },
    {
      "name": "compute_note_hash_and_nullifier",
      "function_type": "Unconstrained",
      "is_internal": false,
      "abi": {
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "param_witnesses": {
          "contract_address": [
            {
              "start": 0,
              "end": 1
            }
          ],
          "nonce": [
            {
              "start": 1,
              "end": 2
            }
          ],
          "serialized_note": [
            {
              "start": 3,
              "end": 6
            }
          ],
          "storage_slot": [
            {
              "start": 2,
              "end": 3
            }
          ]
        },
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "return_witnesses": [
          6,
          7,
          8,
          9
        ]
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "events": [],
  "file_map": {
    "28": {
      "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "39": {
      "source": "contract Counter {\n    // docs:start:imports\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n\n    // docs:end:storage_struct\n\n    // docs:start:storage_init\n    impl Storage {\n        fn init(context: Context) -> Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n    // docs:end:storage_init\n\n    // docs:start:constructor\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n      fn increment(owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n\n    // docs:start:nullifier\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: AztecAddress,\n        nonce: Field,\n        storage_slot: Field,\n        serialized_note: [Field; VALUE_NOTE_LEN]\n    ) -> pub [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, serialized_note)\n    }\n    // docs:end:nullifier\n}\n",
      "path": "/Users/susumu/aztec-tutorial/contracts/counter/src/main.nr"
    },
    "40": {
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    grumpkin_point::GrumpkinPoint,\n};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/log.nr"
    },
    "43": {
      "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/note_getter.nr"
    },
    "44": {
      "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = 0;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note, context);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/lifecycle.nr"
    },
    "45": {
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__OUTER_NULLIFIER,\n    hash::pedersen_hash,\n};\nuse crate::{\n    context::PrivateContext,\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header, context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier_without_context = note_interface.compute_nullifier_without_context;\n    let inner_nullifier = compute_nullifier_without_context(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/utils.nr"
    },
    "47": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n    },\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/note_hash.nr"
    },
    "50": {
      "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/types/vec.nr"
    },
    "60": {
      "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nuse dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/notes.nr"
    },
    "63": {
      "source": "use dep::protocol_types::{\n    address::{\n        AztecAddress,\n        PartialAddress,\n    },\n    grumpkin_point::GrumpkinPoint,\n};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(pub_key, partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/get_public_key.nr"
    },
    "68": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::NUM_FIELDS_PER_SHA256,\n    grumpkin_point::GrumpkinPoint,\n};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: AztecAddress, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/logs.nr"
    },
    "70": {
      "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/rand.nr"
    },
    "73": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::grumpkin_scalar::GrumpkinScalar;\n\nstruct KeyPair {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinScalar,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> KeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    KeyPair {\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinScalar { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> KeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinScalar {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/nullifier_key.nr"
    },
    "79": {
      "source": "use dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n    },\n    contrakt::deployment_data::ContractDeploymentData,\n    hash::hash_args,\n};\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/abi.nr"
    },
    "80": {
      "source": "use crate::{\n    abi::{\n        PrivateContextInputs,\n        PublicContextInputs,\n    },\n    key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        public_call::call_public_function_internal,\n        enqueue_public_function_call::enqueue_public_function_call_internal,\n        context::get_portal_address,\n        get_block_header::get_block_header,\n        nullifier_key::get_nullifier_key_pair,\n    },\n    types::vec::BoundedVec,\n    utils::Reader,\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_data::FunctionData,\n        function_selector::FunctionSelector,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        call_stack_item::PrivateCallStackItem,\n        call_stack_item::PublicCallStackItem,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    },\n    address::{\n        AztecAddress,\n        EthAddress,\n    },\n    constants::{\n        MAX_NEW_COMMITMENTS_PER_CALL,\n        MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NEW_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n        MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_PUBLIC_DATA_READS_PER_CALL,\n        MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n        MAX_READ_REQUESTS_PER_CALL,\n        NUM_FIELDS_PER_SHA256,\n        RETURN_VALUES_LENGTH,\n    },\n    contrakt::{\n        deployment_data::ContractDeploymentData,\n        storage_read::StorageRead,\n        storage_update_request::StorageUpdateRequest,\n    },\n    hash::hash_args,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::{\n    grumpkin_scalar::GrumpkinScalar,\n    option::Option,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(SideEffect::empty()),\n\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n\n            block_header: inputs.block_header,\n\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect {\n            value: read_request,\n            counter: self.side_effect_counter,\n        };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect {\n            value: note_hash,\n            counter: self.side_effect_counter,\n        };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: nullified_commitment,\n            counter: self.side_effect_counter,\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinScalar {\n        let key_pair = get_nullifier_key_pair(account);\n        validate_nullifier_key_against_address(account, key_pair.public_key, key_pair.secret_key);\n        // TODO: Add request to context.\n        // self.context.push_nullifier_key_validation_request(public_key, secret_key);\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_message_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address,\n            function_selector, \n            args_hash,\n            self.side_effect_counter,\n        );\n        let mut reader = Reader::new(fields);\n\n        let item = PrivateCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: FunctionData {\n                selector: FunctionSelector::from_field(reader.read()),\n                is_internal: reader.read() as bool,\n                is_private: reader.read() as bool,\n                is_constructor: reader.read() as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : AztecAddress::from_field(reader.read()),\n                    storage_contract_address : AztecAddress::from_field(reader.read()),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                    function_selector: FunctionSelector::from_field(reader.read()), // practically same as fields[1]\n                    is_delegate_call : reader.read() as bool,\n                    is_static_call : reader.read() as bool,\n                    is_contract_deployment: reader.read() as bool,\n                    start_side_effect_counter: reader.read() as u32,\n                },\n                args_hash: reader.read(),\n                return_values: reader.read_array([0; RETURN_VALUES_LENGTH]), // +1\n                read_requests: reader.read_struct_array(SideEffect::deserialise, [SideEffect::empty(); MAX_READ_REQUESTS_PER_CALL]),\n                new_commitments: reader.read_struct_array(SideEffect::deserialise, [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL]),\n                new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialise, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n                private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n                public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n                new_l2_to_l1_msgs: reader.read_array([0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n                end_side_effect_counter: reader.read() as u32,\n                encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n                unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n                encrypted_log_preimages_length: reader.read(),\n                unencrypted_log_preimages_length: reader.read(),\n                block_header: BlockHeader{\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : reader.read(),\n                    nullifier_tree_root : reader.read(),\n                    contract_tree_root : reader.read(),\n                    l1_to_l2_message_tree_root : reader.read(),\n                    archive_root : reader.read(),\n                    public_data_tree_root: reader.read(),\n                    global_variables_hash: reader.read(),\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: GrumpkinPoint {\n                      x: reader.read(), \n                      y: reader.read()\n                    },\n                    constructor_vk_hash : reader.read(),\n                    function_tree_root : reader.read(),\n                    contract_address_salt : reader.read(),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                },\n                chain_id: reader.read(),\n                version: reader.read(),\n            },\n            is_execution_request: reader.read() as bool,\n        };\n\n        reader.finish();\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n        \n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address));\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n            self.side_effect_counter\n        );\n\n        let mut reader = Reader::new(fields);\n\n        let item = PublicCallStackItem {\n            contract_address:  AztecAddress::from_field(reader.read()),\n            function_data: FunctionData {\n                selector: FunctionSelector::from_field(reader.read()),\n                is_internal: reader.read() as bool,\n                is_private: reader.read() as bool,\n                is_constructor: reader.read() as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : AztecAddress::from_field(reader.read()),\n                    storage_contract_address : AztecAddress::from_field(reader.read()),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                    function_selector: FunctionSelector::from_field(reader.read()), // practically same as fields[1]\n                    is_delegate_call : reader.read() as bool,\n                    is_static_call : reader.read() as bool,\n                    is_contract_deployment: reader.read() as bool,\n                    start_side_effect_counter: reader.read() as u32,\n                },\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: AztecAddress::zero(),\n            },\n            is_execution_request: true,\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address));\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: AztecAddress::zero(),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect {\n            value: note_hash,\n            counter: self.side_effect_counter\n        };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_message_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/context.nr"
    },
    "81": {
      "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\n// TODO(#3470): Copied over from https://github.com/AztecProtocol/aztec-packages/blob/a07c4bd47313be6aa604a63f37857eb0136b41ba/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/base/base_rollup_inputs.nr#L599\n// move to a shared place?\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\nstruct Reader<N> {\n    data: [Field; N],\n    offset: Field,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    } \n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/utils.nr"
    },
    "93": {
      "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{\n    hash::pedersen_hash,\n    traits::{ToField}\n};\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/state_vars/map.nr"
    },
    "94": {
      "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/state_vars/set.nr"
    },
    "134": {
      "source": "use crate::{\n    constants::{\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n    },\n    hash::pedersen_hash,\n    utils,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(pub_key: GrumpkinPoint, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_key.x, pub_key.y, partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n    \n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl EthAddress{\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(contract_address_salt : Field, function_tree_root : Field, constructor_hash : Field) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash([\n                // TODO why the zeroes?\n                0,\n                0,\n                contract_address_salt,\n                function_tree_root,\n                constructor_hash\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/noir-protocol-circuits/src/crates/types/src/address.nr"
    },
    "157": {
      "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::utils::bounded_vec::BoundedVec;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    function_tree_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, function_tree_root };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"
    },
    "166": {
      "source": "use dep::aztec::{\n    protocol_types::address::AztecAddress,\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: AztecAddress) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: AztecAddress) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner.eq(owner));\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/easy-private-state/src/easy_private_state.nr"
    },
    "168": {
      "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained pub fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/value-note/src/balance_utils.nr"
    },
    "171": {
      "source": "use dep::aztec::{\n    protocol_types::address::AztecAddress,\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        nullifier_key::get_nullifier_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    pub fn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(serialized_note)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote, context: &mut PrivateContext) -> Field {\n    note.compute_nullifier(context)\n}\n\nfn compute_nullifier_without_context(note: ValueNote) -> Field {\n    note.compute_nullifier_without_context()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    compute_nullifier_without_context,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
      "path": "/Users/susumu/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.20.0/yarn-project/aztec-nr/value-note/src/value_note.nr"
    }
  }
}
